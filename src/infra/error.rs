use std::fmt::Debug;

use argon2::password_hash;
use axum::http::StatusCode;
use macros::{ApiError, IntoErrorSchema};
use sea_orm::DbErr;

use super::database::error::FkViolation;
use crate::presentation::api_response::{
    IntoApiResponse, default_into_api_response_impl,
};

/// Note: Don't impl from for variants
#[derive(Debug, snafu::Snafu, ApiError, IntoErrorSchema)]
pub enum Error {
    #[snafu(transparent)]
    #[api_error(
        status_code = StatusCode::INTERNAL_SERVER_ERROR,
        into_response = self
    )]
    Internal {
        source: Box<dyn std::error::Error + Send + Sync>,
    },
    #[snafu(transparent)]
    User { source: UserError },
}

impl Error {
    pub fn custom(message: &impl ToString) -> Self {
        Self::Internal {
            source: Box::new(CustomMsgError(message.to_string())),
        }
    }

    pub fn internal(
        err: impl std::error::Error + Send + Sync + 'static,
    ) -> Self {
        Self::Internal {
            source: Box::new(err),
        }
    }
}

#[derive(Debug)]
struct CustomMsgError(String);

impl std::fmt::Display for CustomMsgError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for CustomMsgError {}

// impl From<Box<dyn std::error::Error + Send + Sync>> is generated by SNAFU due to the transparent variant

impl From<DbErr> for Error {
    fn from(err: DbErr) -> Self {
        Self::internal(err)
    }
}

impl From<tokio::task::JoinError> for Error {
    fn from(err: tokio::task::JoinError) -> Self {
        Self::internal(err)
    }
}

impl From<std::io::Error> for Error {
    fn from(err: std::io::Error) -> Self {
        Self::internal(err)
    }
}

impl From<password_hash::Error> for Error {
    fn from(err: password_hash::Error) -> Self {
        Self::internal(err)
    }
}

impl IntoApiResponse for Error {
    fn into_api_response(self) -> axum::response::Response {
        match self {
            Self::Internal { ref source } => {
                tracing::error!("Internal error: {:?}", source);
                default_into_api_response_impl(self)
            }
            Self::User { source } => source.into_api_response(),
        }
    }
}

#[derive(Debug, snafu::Snafu, ApiError)]

pub enum UserError {
    #[snafu(transparent)]
    FkViolation { source: FkViolation<DbErr> },
}

#[cfg(test)]
mod test {

    use axum::response::IntoResponse;
    use tracing_test::traced_test;

    use super::*;
    use crate::presentation::error::ApiError;

    // https://github.com/dbrgn/tracing-test/issues/48
    // This bug causes errors with line breaks cannot be captured
    // So I can only test the prefix of errors here
    // If this test fails, it may be because error messages has been changed
    #[tokio::test]
    #[traced_test]
    async fn test_nested_err_print() {
        let err = Error::internal(DbErr::Custom("foobar".to_string()));
        let err = ApiError::Infra { source: err };

        let _ = err.into_response();

        assert!(logs_contain("Custom"));
        assert!(logs_contain("foobar"));

        // cranelift dosen't support catch_unwind yet
        // let err = ServiceError::Tokio(TokioError::TaskJoin(
        //     async {
        //         let handle = tokio::spawn(async {
        //             panic!("fake panic");
        //         });

        //         match handle.await {
        //             Err(e) => e,
        //             _ => unreachable!(),
        //         }
        //     }
        //     .await,
        // ));

        // let _ = err.into_response();

        // assert!(logs_contain("Tokio error: TaskJoin"));
    }
}
